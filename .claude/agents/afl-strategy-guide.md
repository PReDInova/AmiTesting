# AFL Strategy Development Guide

## Purpose

This guide captures the architecture, constraints, and proven patterns for creating and modifying AmiBroker AFL strategies in this project. Follow these rules whenever writing or editing AFL code, configuring APX files, or adding custom indicator columns to backtest results.

---

## Architecture Overview

The pipeline runs in this order:

1. **AFL strategy** is read from the SQLite database (version system) and written to `afl/ma_crossover.afl`.
2. **APX builder** (`scripts/apx_builder.py`) creates a `.apx` project file from the AFL + template (`apx/base.apx`).
3. **OLE backtester** (`scripts/ole_backtest.py`) launches AmiBroker via COM, loads the database, opens the APX, runs the backtest (run_mode=2), and exports CSV/HTML results.
4. **Indicator exploration** (optional, Step 2a in `run.py`) runs a second lightweight AmiBroker session to compute per-bar indicator values and merges them into the trades CSV.
5. **Dashboard** (`dashboard/app.py` + `dashboard/templates/results_detail.html`) renders the results with a Column Chooser UI that tags non-standard columns with a CUSTOM badge.

---

## Critical Constraints

### NEVER use Custom Backtest Procedure (CBT)

**CBT causes AmiBroker to go "Not Responding" and hang indefinitely.** This was confirmed through extensive testing. The following AFL patterns are BANNED:

```afl
// BANNED -- causes AmiBroker hang:
SetCustomBacktestProc("");
bo = GetBacktesterObject();
bo.Backtest();
bo.ListTrades();
```

Any approach that uses `GetBacktesterObject()`, `bo.Backtest()`, or `bo.ListTrades()` will cause the COM automation to fail silently with AmiBroker becoming unresponsive.

### NEVER use AFL file I/O for data export

**AFL `fopen`/`fputs`/`fclose` do not reliably write files when run via COM automation.** The dialog handler's "Keep existing file" behavior causes AmiBroker to use cached formulas, and the file I/O calls silently fail. Do not use:

```afl
// BANNED -- files are never written via COM:
fh = fopen("C:\\path\\output.csv", "w");
fputs(header, fh);
fclose(fh);
```

### NEVER embed indicator computation in AFL trade signals

Keep the AFL strategy clean: signal logic + visualization only. Indicator computation for custom columns happens via the **exploration-based approach** (see below).

---

## How Custom Indicator Columns Work

### The Exploration Approach (proven, reliable)

Instead of CBT or file I/O, custom indicator values are computed by running an AmiBroker **Exploration** (run_mode=1) after the backtest completes. This is handled automatically by Step 2a in `run.py`.

**Flow:**

1. Backtest runs (run_mode=2) and exports trades CSV.
2. A lightweight exploration AFL is generated that computes the same indicators as the strategy.
3. The exploration AFL is wrapped in an APX and run via OLE (run_mode=1).
4. The exploration exports per-bar indicator values for all 353K+ bars.
5. Python merges indicator values into the trades CSV by matching entry/exit timestamps.

**The exploration AFL must:**
- Compute the same indicator variables as the strategy AFL.
- Use `Filter = Name() == "SYMBOL";` to restrict output to the target symbol.
- Use `AddColumn(variable, "ColumnName");` for each indicator to export.
- NOT include any signal logic, stops, position sizing, or visualization.

**Example exploration AFL (auto-generated by run.py):**

```afl
temaLength = 8;
lookback = 5;
ema1 = EMA(Close, temaLength);
ema2 = EMA(ema1, temaLength);
ema3 = EMA(ema2, temaLength);
temas = 3 * ema1 - 3 * ema2 + ema3;
firstDeriv = (temas - Ref(temas, -lookback)) / lookback;
secondDeriv = firstDeriv - Ref(firstDeriv, -lookback);
temaSlope = temas - Ref(temas, -1);
Filter = Name() == "NQ";
AddColumn(temaSlope, "TEMASlope");
AddColumn(firstDeriv, "1stDeriv");
AddColumn(secondDeriv, "2ndDeriv");
```

### Where the exploration code lives in run.py

The exploration is built and run in the `# --- Step 2a` block (~line 360-507 of `run.py`). It:

1. Parses AFL parameters from `Param()` calls using regex.
2. Generates exploration AFL with matching indicator computations.
3. Builds an APX with `build_apx(..., run_id=run_id + "_exp", symbol="__ALL__")`.
4. Runs via `OLEBacktester.run_full_test(..., run_mode=1)`.
5. Reads the exploration CSV with `pd.read_csv(..., index_col=False)`.
6. Parses dates with `pd.to_datetime(..., format="mixed")`.
7. Merges indicator values at entry/exit timestamps using `reindex()`.

### Adding custom columns for a new strategy

When creating a new strategy that needs custom indicator columns:

1. **Write the strategy AFL** with clean signal logic only (no CBT, no file I/O).
2. **Update the Step 2a block in `run.py`** to detect the new strategy and generate the appropriate exploration AFL. Currently it detects the target symbol via `Name() == "..."` and parses `Param()` calls for TEMA and derivative parameters.
3. **Update the dashboard Column Chooser** in `results_detail.html`:
   - Add new column names (lowercase) to the `defaultCols` array if they should be visible by default.
   - Do NOT add them to `standardCols` -- they must be absent from that list to get the CUSTOM badge.

---

## AmiBroker OLE Run Modes

These are the action values for `AnalysisDoc.Run(nAction)`:

| Value | Mode | Use Case |
|-------|------|----------|
| 0 | Scan | Not used in this project |
| 1 | **Exploration** | Custom indicator column export |
| 2 | **Portfolio Backtest** | Primary backtest mode |
| 3 | Individual Backtest | Not used |
| 4 | Portfolio Optimization | Parameter optimization |
| 5 | Individual Optimization | Not used |
| 6 | Walk Forward Test | Not used |

**CRITICAL:** Exploration is mode **1**, not 3. Using the wrong mode produces zero rows.

---

## APX Builder Gotchas

### FormulaContent must be populated

The APX builder (`scripts/apx_builder.py`) populates `<FormulaContent>` with the AFL encoded in AmiBroker's format. This is critical because:

- If FormulaContent is empty, AmiBroker shows a "Formula is different" dialog.
- The dialog handler clicks "Keep existing file" which uses a cached/wrong formula.
- FormulaContent eliminates the dialog entirely.

**Encoding format for FormulaContent:**
- Newlines become literal `\r\n` (the 4-character string, not actual CRLF).
- XML entities: `&` -> `&amp;`, `<` -> `&lt;`, `>` -> `&gt;`.
- File encoding: ISO-8859-1.
- The content must match the snapshot file byte-for-byte after AmiBroker decodes it.

### APX XML fields

| Field | Description | Common Values |
|-------|-------------|---------------|
| `<Periodicity>` | Bar interval | 0=Tick, 5=1-min, 9=Hourly, 11=Daily |
| `<ApplyTo>` | Symbol scope | 0=All symbols, 1=Current symbol |
| `<Symbol>` | Ticker | e.g. "GCZ5", "NQ" |
| `<FormulaPath>` | AFL file path | Double backslashes: `C:\\path\\file.afl` |
| `<FormulaContent>` | Encoded AFL | See encoding format above |
| `<RangeType>` | Date range | 0=All quotations |

### Auto-detection in run.py

The pipeline auto-detects AFL requirements:

- `Name() == "..."` in AFL -> sets ApplyTo=0 (all symbols) and defaults to Periodicity=5 (1-min).
- `TimeFrameSet(...)` in AFL -> sets Periodicity=0 (Tick).

---

## AmiBroker Exploration CSV Quirks

When parsing CSVs exported by AmiBroker explorations:

1. **Trailing comma on every data row.** AmiBroker adds an extra comma to each row, creating N+1 fields vs N header columns. Fix: `pd.read_csv(..., index_col=False)`.

2. **Mixed datetime formats.** Midnight bars use `MM/DD/YYYY 00:00:00` (24-hour) while all other bars use `MM/DD/YYYY HH:MM:SS AM/PM` (12-hour). Fix: `pd.to_datetime(..., format="mixed")`.

3. **Backtest CSV datetime format.** Trade dates use `MM/DD/YYYY H:MM:SS AM/PM` (no leading zero on hour). The `format="mixed"` parser handles both formats.

---

## AFL Strategy Template

Use this template for new strategies:

```afl
// ===========================================
// STRATEGY_ID - Strategy Name
// ===========================================
//
// Brief description of the strategy logic.
//
// Entry:
//   Buy   = [entry condition for longs]
//   Short = [entry condition for shorts]
//
// Exit: [exit method description]
//
// APX requirements: Periodicity=X, ApplyTo=Y.
// [Symbol filter note if applicable]

// ---- Symbol filter (if using portfolio mode) ----
isTargetSymbol = Name() == "SYMBOL";

// ---- Strategy Parameters ----
// Use Param() for all tunable values.
param1 = Param("Param Name", default, min, max, step);

// ---- Indicator Computation ----
// Compute indicators here. These same computations must be
// replicated in the exploration AFL for custom columns.

// ---- Entry Signals ----
rawBuy   = [conditions] AND isTargetSymbol;
rawShort = [conditions] AND isTargetSymbol;

// ---- Trade Delays (enter on next bar open) ----
SetTradeDelays(1, 1, 1, 1);
BuyPrice   = Open;
SellPrice  = Open;
ShortPrice = Open;
CoverPrice = Open;

// ---- Assign Signals ----
Buy   = rawBuy;
Sell  = 0;   // exits handled by ApplyStop
Short = rawShort;
Cover = 0;   // exits handled by ApplyStop

// ---- Stops ----
ApplyStop(stopTypeLoss, stopModePoint, stopPoints);
ApplyStop(stopTypeProfit, stopModePoint, targetPoints);

// ---- Position sizing ----
SetPositionSize(1, spsShares);

// ---- Remove duplicate signals ----
Buy   = ExRem(Buy, Short);
Short = ExRem(Short, Buy);

// ---- Visualization ----
Plot(Close, "Price", colorDefault, styleCandle);
// Plot indicators, entry arrows, title, etc.
```

**Key rules:**
- NO `SetCustomBacktestProc` or `GetBacktesterObject`.
- NO `fopen`, `fputs`, `fclose`.
- NO `AddColumn` or `Filter` (those belong in the exploration AFL).
- Use `Param()` for all tunable values so run.py can extract them.
- Always include the symbol filter pattern `Name() == "SYMBOL"` for symbol-specific strategies.

---

## Dashboard Column Chooser

### How it works

In `results_detail.html`, the Column Chooser JavaScript:

1. Defines `standardCols` -- the list of built-in AmiBroker trade columns.
2. Defines `defaultCols` -- columns visible by default (including custom ones).
3. Any column NOT in `standardCols` gets a blue dot and "CUSTOM" label.
4. Visibility state persists in localStorage per-run.

### Adding new custom columns

1. Add the column name (lowercase) to `defaultCols` if it should be visible by default.
2. Do NOT add it to `standardCols` -- this ensures it gets the CUSTOM badge.
3. Column names follow the pattern: `indicatorname@entry` and `indicatorname@exit`.

**Current custom columns:** `temaslope@entry`, `temaslope@exit`, `1stderiv@entry`, `1stderiv@exit`, `2ndderiv@entry`, `2ndderiv@exit`.

---

## Lessons Learned (D02 Development)

| Approach | Result | Why |
|----------|--------|-----|
| CBT (Custom Backtest Procedure) | AmiBroker hangs | `bo.Backtest()` + COM = "Not Responding" |
| AFL file I/O (`fopen`/`fputs`) | Files never written | Dialog handler uses cached formula |
| COM bar-by-bar export (`quotes(i)`) | Too slow | 353K bars via COM takes ~1 hour |
| AmiBroker binary DB reader | Format unknown | Proprietary format, not documented |
| **Exploration (run_mode=1)** | **Works** | 353K bars in ~1 second, reliable |

### Other pitfalls discovered

- `run_mode=3` is "Individual Backtest", NOT exploration. Exploration is `run_mode=1`.
- AmiBroker exploration CSV has a trailing comma on every data row.
- AmiBroker uses mixed 12h/24h time formats in exploration exports.
- `FormulaContent` must be populated to prevent the "formula is different" dialog.
- Each APX run needs a unique filename to avoid cached formula conflicts.
- The `populate_content` parameter in `build_apx()` defaults to `True` and should stay that way.

---

## File Reference

| File | Purpose |
|------|---------|
| `strategies/*.afl` | Strategy source files (clean signal logic only) |
| `run.py` | Pipeline orchestrator (backtest + exploration + merge) |
| `scripts/apx_builder.py` | APX file generator with FormulaContent encoding |
| `scripts/ole_backtest.py` | AmiBroker COM automation (connect, run, export) |
| `scripts/dialog_handler.py` | Auto-dismisses AmiBroker modal dialogs |
| `scripts/strategy_db.py` | SQLite strategy/version/run management |
| `config/settings.py` | Paths, symbols, backtest settings |
| `apx/base.apx` | APX XML template |
| `dashboard/templates/results_detail.html` | Results UI with Column Chooser |
